package fin.service;

import fin.model.TransactionMappingRule;
import fin.config.DatabaseConfig;

import java.sql.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * Classification Rule Manager
 * 
 * SINGLE RESPONSIBILITY: Manage classification rules (CRUD operations)
 * 
 * This service handles:
 * - Creating new classification rules
 * - Updating existing rules
 * - Deleting rules
 * - Managing rule usage statistics
 * - Rule persistence and retrieval
 * 
 * Created: October 11, 2025 - Extracted from InteractiveClassificationService
 */
public class ClassificationRuleManager {
    private static final Logger LOGGER = Logger.getLogger(ClassificationRuleManager.class.getName());
    
    private final String dbUrl;
    private final AccountClassificationService accountClassificationService;
    
    /**
     * Data class for classification rules with usage statistics
     */
    public static class ClassificationRule {
        private final Long id;
        private final Long companyId;
        private final String pattern;
        private final String[] keywords;
        private final String accountCode;
        private final String accountName;
        private final int usageCount;
        private final Timestamp createdAt;
        private final Timestamp lastUsed;
        
        public ClassificationRule(Long id, Long companyId, String pattern, String[] keywords, 
                                String accountCode, String accountName, int usageCount,
                                Timestamp createdAt, Timestamp lastUsed) {
            this.id = id;
            this.companyId = companyId;
            this.pattern = pattern;
            this.keywords = keywords != null ? keywords.clone() : new String[0];
            this.accountCode = accountCode;
            this.accountName = accountName;
            this.usageCount = usageCount;
            this.createdAt = createdAt != null ? new Timestamp(createdAt.getTime()) : null;
            this.lastUsed = lastUsed != null ? new Timestamp(lastUsed.getTime()) : null;
        }
        
        // Getters
        public Long getId() { return id; }
        public Long getCompanyId() { return companyId; }
        public String getPattern() { return pattern; }
        public String[] getKeywords() { return keywords != null ? keywords.clone() : new String[0]; }
        public String getAccountCode() { return accountCode; }
        public String getAccountName() { return accountName; }
        public int getUsageCount() { return usageCount; }
        public Timestamp getCreatedAt() { return createdAt != null ? new Timestamp(createdAt.getTime()) : null; }
        public Timestamp getLastUsed() { return lastUsed != null ? new Timestamp(lastUsed.getTime()) : null; }
    }
    
    public ClassificationRuleManager() {
        this.dbUrl = DatabaseConfig.getDatabaseUrl();
        this.accountClassificationService = new AccountClassificationService(dbUrl);
        initializeDatabase();
    }
    
    /**
     * Initialize database tables for classification rules
     */
    private void initializeDatabase() {
        try (Connection conn = DriverManager.getConnection(dbUrl);
             Statement stmt = conn.createStatement()) {
            
            // Create company classification rules table
            String sql = """
                CREATE TABLE IF NOT EXISTS company_classification_rules (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    company_id BIGINT NOT NULL,
                    pattern VARCHAR(1000) NOT NULL,
                    keywords VARCHAR(2000) NOT NULL,
                    account_code VARCHAR(20) NOT NULL,
                    account_name VARCHAR(255) NOT NULL,
                    usage_count INTEGER DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_used TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (company_id) REFERENCES companies(id)
                )
                """;
            
            stmt.executeUpdate(sql);
            
            // Create index for faster lookups
            stmt.executeUpdate("""
                CREATE INDEX IF NOT EXISTS idx_classification_rules_company 
                ON company_classification_rules(company_id, account_code)
                """);
                
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error initializing classification database", e);
        }
    }
    
    /**
     * Create a new classification rule
     * 
     * @param companyId The company ID
     * @param pattern The transaction pattern to match
     * @param accountCode The account code to assign
     * @param accountName The account name to assign
     * @return The created rule ID or null if creation failed
     */
    public Long createRule(Long companyId, String pattern, String accountCode, String accountName) {
        if (companyId == null || pattern == null || accountCode == null || accountName == null) {
            LOGGER.warning("Cannot create rule: missing required parameters");
            return null;
        }
        
        try {
            // Extract keywords for future matching
            String[] keywords = extractKeywords(pattern);
            
            // Check if rule already exists
            String checkSql = """
                SELECT id, usage_count FROM company_classification_rules 
                WHERE company_id = ? AND account_code = ? AND pattern ILIKE ?
                """;
                
            String updateSql = """
                UPDATE company_classification_rules 
                SET usage_count = usage_count + 1, keywords = ?, last_used = CURRENT_TIMESTAMP
                WHERE id = ?
                """;
                
            String insertSql = """
                INSERT INTO company_classification_rules 
                (company_id, pattern, keywords, account_code, account_name, usage_count, created_at, last_used)
                VALUES (?, ?, ?, ?, ?, 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                RETURNING id
                """;
            
            try (Connection conn = DriverManager.getConnection(dbUrl)) {
                // Check for existing rule
                try (PreparedStatement checkStmt = conn.prepareStatement(checkSql)) {
                    checkStmt.setLong(1, companyId);
                    checkStmt.setString(2, accountCode);
                    checkStmt.setString(3, "%" + pattern + "%");
                    
                    ResultSet rs = checkStmt.executeQuery();
                    
                    if (rs.next()) {
                        // Update existing rule
                        Long existingId = rs.getLong("id");
                        try (PreparedStatement updateStmt = conn.prepareStatement(updateSql)) {
                            updateStmt.setString(1, String.join(",", keywords));
                            updateStmt.setLong(2, existingId);
                            updateStmt.executeUpdate();
                            
                            LOGGER.info("Updated existing rule: " + pattern + " → " + accountCode);
                            return existingId;
                        }
                    } else {
                        // Create new rule
                        try (PreparedStatement insertStmt = conn.prepareStatement(insertSql)) {
                            insertStmt.setLong(1, companyId);
                            insertStmt.setString(2, pattern);
                            insertStmt.setString(3, String.join(",", keywords));
                            insertStmt.setString(4, accountCode);
                            insertStmt.setString(5, accountName);
                            
                            ResultSet insertRs = insertStmt.executeQuery();
                            if (insertRs.next()) {
                                Long newId = insertRs.getLong("id");
                                LOGGER.info("Created new rule: " + pattern + " → " + accountCode + " - " + accountName);
                                return newId;
                            }
                        }
                    }
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error creating classification rule", e);
        }
        
        return null;
    }
    
    /**
     * Update usage count for a classification rule
     * 
     * @param ruleId The rule ID to update
     * @return true if updated successfully
     */
    public boolean incrementRuleUsage(Long ruleId) {
        if (ruleId == null) {
            return false;
        }
        
        try {
            String sql = """
                UPDATE company_classification_rules 
                SET usage_count = usage_count + 1, last_used = CURRENT_TIMESTAMP
                WHERE id = ?
                """;
                
            try (Connection conn = DriverManager.getConnection(dbUrl);
                 PreparedStatement stmt = conn.prepareStatement(sql)) {
                
                stmt.setLong(1, ruleId);
                int updated = stmt.executeUpdate();
                
                return updated > 0;
            }
        } catch (SQLException e) {
            LOGGER.log(Level.WARNING, "Error incrementing rule usage", e);
        }
        
        return false;
    }
    
    /**
     * Get all classification rules for a company
     * 
     * @param companyId The company ID
     * @return List of classification rules ordered by usage count
     */
    public List<ClassificationRule> getRulesByCompany(Long companyId) {
        List<ClassificationRule> rules = new ArrayList<>();
        
        if (companyId == null) {
            return rules;
        }
        
        String sql = """
            SELECT id, company_id, pattern, keywords, account_code, account_name, 
                   usage_count, created_at, last_used
            FROM company_classification_rules
            WHERE company_id = ?
            ORDER BY usage_count DESC, created_at DESC
            """;
            
        try (Connection conn = DriverManager.getConnection(dbUrl);
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setLong(1, companyId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                String keywordsStr = rs.getString("keywords");
                String[] keywords = keywordsStr != null ? keywordsStr.split(",") : new String[0];
                
                rules.add(new ClassificationRule(
                    rs.getLong("id"),
                    rs.getLong("company_id"),
                    rs.getString("pattern"),
                    keywords,
                    rs.getString("account_code"),
                    rs.getString("account_name"),
                    rs.getInt("usage_count"),
                    rs.getTimestamp("created_at"),
                    rs.getTimestamp("last_used")
                ));
            }
            
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error loading classification rules", e);
        }
        
        return rules;
    }
    
    /**
     * Delete a classification rule
     * 
     * @param ruleId The rule ID to delete
     * @param companyId The company ID (for security)
     * @return true if deleted successfully
     */
    public boolean deleteRule(Long ruleId, Long companyId) {
        if (ruleId == null || companyId == null) {
            return false;
        }
        
        try {
            String sql = """
                DELETE FROM company_classification_rules 
                WHERE id = ? AND company_id = ?
                """;
                
            try (Connection conn = DriverManager.getConnection(dbUrl);
                 PreparedStatement stmt = conn.prepareStatement(sql)) {
                
                stmt.setLong(1, ruleId);
                stmt.setLong(2, companyId);
                int deleted = stmt.executeUpdate();
                
                if (deleted > 0) {
                    LOGGER.info("Deleted classification rule: " + ruleId);
                    return true;
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error deleting classification rule", e);
        }
        
        return false;
    }
    
    /**
     * Get most used accounts for a company
     * 
     * @param companyId The company ID
     * @param limit Maximum number of accounts to return
     * @return List of account codes and names ordered by usage
     */
    public List<Map<String, Object>> getMostUsedAccounts(Long companyId, int limit) {
        List<Map<String, Object>> accounts = new ArrayList<>();
        
        if (companyId == null) {
            return accounts;
        }
        
        String sql = """
            SELECT account_code, account_name, SUM(usage_count) as total_usage
            FROM company_classification_rules 
            WHERE company_id = ? 
            GROUP BY account_code, account_name
            ORDER BY total_usage DESC, account_code ASC
            LIMIT ?
            """;
            
        try (Connection conn = DriverManager.getConnection(dbUrl);
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setLong(1, companyId);
            stmt.setInt(2, limit);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Map<String, Object> account = new HashMap<>();
                account.put("accountCode", rs.getString("account_code"));
                account.put("accountName", rs.getString("account_name"));
                account.put("usageCount", rs.getInt("total_usage"));
                accounts.add(account);
            }
            
        } catch (SQLException e) {
            LOGGER.log(Level.WARNING, "Error loading most used accounts", e);
        }
        
        return accounts;
    }
    
    /**
     * Initialize standard classification rules for a company
     * Uses AccountClassificationService as single source of truth
     * 
     * @param companyId The company ID
     * @return Number of rules created
     */
    public int initializeStandardRules(Long companyId) {
        if (companyId == null) {
            return 0;
        }
        
        List<TransactionMappingRule> standardRules = accountClassificationService.getStandardMappingRules();
        int createdCount = 0;
        
        for (TransactionMappingRule rule : standardRules) {
            String accountCode = extractAccountCodeFromRuleDescription(rule.getDescription());
            if (accountCode != null) {
                Long ruleId = createRule(companyId, rule.getMatchValue(), accountCode, rule.getRuleName());
                if (ruleId != null) {
                    createdCount++;
                }
            }
        }
        
        LOGGER.info("Initialized " + createdCount + " standard rules for company " + companyId);
        return createdCount;
    }
    
    /**
     * Extract account code from rule description (format: "[AccountCode:XXXX]")
     */
    private String extractAccountCodeFromRuleDescription(String description) {
        if (description == null) return null;
        
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("\\[AccountCode:(\\d+(?:-\\d+)?)\\]");
        java.util.regex.Matcher matcher = pattern.matcher(description);
        
        if (matcher.find()) {
            return matcher.group(1);
        }
        return null;
    }
    
    /**
     * Extract keywords from transaction description for pattern matching
     */
    private String[] extractKeywords(String description) {
        if (description == null) return new String[0];
        
        // Remove common words and extract meaningful keywords
        String[] commonWords = {"the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with", "by"};
        Set<String> commonWordsSet = Set.of(commonWords);
        
        return Arrays.stream(description.toLowerCase().split("\\W+"))
                .filter(word -> word.length() > 2)
                .filter(word -> !commonWordsSet.contains(word))
                .limit(5) // Take top 5 keywords
                .toArray(String[]::new);
    }
}